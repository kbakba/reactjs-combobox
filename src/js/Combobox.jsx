/** @jsx React.DOM */
/* jshint newcap: false */
/* global React */

/**
 * @namespace My Namespace
 */
var NS = NS || {};

/**
 * @module Combobox
 */
NS.Combobox = (function(React) {

    var cx = React.addons.classSet;

    /**
     * @const CSS Component prefix
     */
    var CSS_PREFIX = 'Combobox';

    /**
     * Partial
     * @see http://underscorejs.org/#partial
     */
    var _partial = function(func) {
        var boundArgs = Array.prototype.slice.call(arguments, 1);
        return function() {
            var position = 0;
            var args = boundArgs.slice();
            while (position < arguments.length) {
                args.push(arguments[position++]);
            }
            return func.apply(this, args);
        };
    };

    /**
     * Generate CSS class for Element
     * @param  {string} blockName
     * @param  {string} elemName  Element name
     * @return {string}           CSS class for Element
     */
    var _clsElem = function(blockName, elemName) {
        var className = blockName + '__' + elemName;
        return className;
    };

    /**
     * It is _clsState() with predefined blockName=CSS_PREFIX
     * @see _clsElem
     */
    var clsElem = _partial(_clsElem, CSS_PREFIX);

    /**
     * Generate CSS class for Block or Element state (modificator)
     * @param  {string} blockName Block name or Element name generated by clsElem
     * @param  {string} stateName
     * @param  {string} [stateValue]
     * @return {string}             CSS class for Block or Element with state
     */
    var clsState = function(blockName, stateName, stateValue) {
        var className = blockName + '_' + stateName +
                        ((stateValue == null) ? '' : '-' +  stateValue);
        return className;
    };

    /**
     * It is clsState() with predefined blockName=CSS_PREFIX
     * @see clsState
     */
    var clsBlockState = _partial(clsState, CSS_PREFIX);

    /**
     * Combo box option UI component
     * @class
     */
    var ComboboxOption = React.createClass({
        // Default component methods
        propTypes: {
            selected: React.PropTypes.bool,
            children: React.PropTypes.string.isRequired,
            value: React.PropTypes.object,
            onClick: React.PropTypes.func
        },

        getDefaultProps: function() {
            return {
                selected: false,
                children: "",
                value: null
            };
        },

        render: function() {
            var cls = {};
            cls[clsElem('dropdownOption')] = true;
            cls[clsState(clsElem('dropdownOption'), 'selected')] = this.props.selected;

            return (
                <li className={cx(cls)} onClick={this.onClick}>
                    {this.props.children}
                </li>
            );
        },

        onClick: function(evt) {
            this.props.onClick(evt, this.props.label, this.props.value);
            return false;
        }
    });

    /**
     * Combo box UI component
     * @class
     */
    var Combobox = React.createClass({
        // Default component methods
        propTypes: {
            // Default data items
            data: React.PropTypes.arrayOf(
                    React.PropTypes.shape({ label: React.PropTypes.string.isRequired })
                ).isRequired,
            // Default text value
            defaultValue: React.PropTypes.string,
            // Combobox id disabled
            disabled: React.PropTypes.bool,
            // Function for filter items in data (uses value from text field)
            filterFunc: React.PropTypes.oneOfType([
                            React.PropTypes.func,
                            React.PropTypes.oneOf([false])
                        ]),
            // Function which will be invoked when value is changed
            onChange: React.PropTypes.func
        },

        getDefaultProps: function() {
            return {
                data: [],
                defaultValue: "",
                disabled: false,
                filterFunc: function(textValue, item){
                    var s = textValue.toLowerCase().replace(' ', '');
                    return item.label.toLowerCase().replace(' ', '').indexOf(s) >= 0;
                },
                onChange: function() {},
            };
        },

        getInitialState: function() {
            var _filtratedData = this.props.data;
            if (this.props.defaultValue !== '') {
                _filtratedData = this._getFiltratedData(this.props.defaultValue, this.props.data);
            }

            return {
                isOpen: false,
                isEnabled: !this.props.disabled,
                _data: this.props.data,
                _filtratedData: _filtratedData,
                _textValue: this.props.defaultValue,
                _selectedOptionData: null,
                _selectedIndex: -1,
                additionalClassName: ''
            };
        },

        render: function() {
            var cls = {};
            cls[CSS_PREFIX] = true;
            cls[clsBlockState('closed')] = !this.state.isOpen;
            cls[clsBlockState('disabled')] = !this.state.isEnabled;

            var dropdown = "";
            if (this.state.isEnabled) {
                dropdown = (
                    <div className={clsElem('dropdown')}>
                        <div className={clsElem('dropdownWrapper')}>
                            <ul className={clsElem('dropdownList')}>
                                {this.state._filtratedData.map(this._dataToOption)}
                            </ul>
                        </div>
                    </div>
                );
            }
            return (
                <div className={cx(cls) + ' ' + this.state.additionalClassName}
                    onKeyDown={this._handleKeyDown}
                    onBlur={this._blur}>
                    <input
                        ref="textField"
                        type="text"
                        disabled={!this.state.isEnabled}
                        className={clsElem('input')}
                        value={this.state._textValue}
                        onChange={this._handleTextChange}
                        onFocus={this._focus}/>
                    {dropdown}
                    <span className={clsElem('buttonWrapper')}>
                        <button
                            ref="button"
                            type="button"
                            onClick={this._handleButtonClick}
                            className={clsElem('button')}
                            disabled={!this.state.isEnabled}>â–¼</button>
                    </span>
                </div>
            );
        },

        componentDidUpdate: function(prevProps, prevState) {
            if (prevState._textValue !== this.state._textValue) {
                this.props.onChange(this.state._textValue, prevState._textValue);
            }
        },

        componentWillReceiveProps: function(nextProps) {
            this.setData(nextProps.data);
        },

        // Custom component methods
        // Private
        _timerId: null,

        /**
         * Convert dataItem to <Option/>
         * @param  {object} dataItem
         * @param  {string} dataItem.label Label for option
         * @param  {number} idx index of element
         * @return {<Option/>}
         */
        _dataToOption: function(dataItem, idx) {
            var label = dataItem.label;
            var selected = (idx === this.state._selectedIndex);
            var item = (
                <ComboboxOption
                    selected={selected}
                    label={label}
                    value={dataItem}
                    key={'key-' + label.toLowerCase().replace(' ', '')}
                    onClick={this._handleOptionClick}>
                    {label}
                </ComboboxOption>
            );
            return item;
        },

        /**
         * Handle textField change
         * @param  {event} evt
         * @return false
         */
        _handleTextChange: function(evt) {
            var newValue = evt.target.value;
            this.setState({
                _selectedIndex: -1,
                _selectedOptionData: null
            });
            this.setTextValue(newValue, true);
            return false;
        },

        /**
         * Handle <Option> click
         * @param  {event} evt
         * @param  {string} label <Option/> label
         * @param  {object} dataItem <Option/> dataItem
         * @return false
         */
        _handleOptionClick: function(evt, label, dataItem) {
            this.setState({_selectedOptionData: dataItem});
            this.setTextValue(label);
            return false;
        },

        /**
         * Handle textField keyDown
         * @param  {event} evt
         * @return {bool} false if is ArrowDown/ArrowUp/Enter/Escape keys
         */
        _handleKeyDown: function(evt) {
            var result = true;
            if (evt.key === 'ArrowDown') {
                this._moveOptionSelection(1);
                result = false;
            } else if (evt.key === 'ArrowUp') {
                this._moveOptionSelection(-1);
                result = false;
            } else if (evt.key === 'Enter') {
                var dataItem = this.state._filtratedData[this.state._selectedIndex];
                if (dataItem) {
                    this._handleOptionClick(null, dataItem['label'], dataItem);
                }
                this.refs.textField.getDOMNode().blur();
                result = false;
            } else if (evt.key === 'Escape') {
                this.refs.textField.getDOMNode().blur();
                this.close();
                result = false;
            }
            return result;
        },

        /**
         * Handle button click
         * @param  {event} evt
         */
        _handleButtonClick: function(evt) {
            if (!this.state.isOpen) {
                this.refs.textField.getDOMNode().focus();
            }
            return false;
        },

        /**
         * Handle textField focus
         * @param  {event} evt
         */
        _focus: function(evt) {
            clearTimeout(this._timerId);
            delete this._timerId;

            var textField = evt.target;
            var newValue = textField.value;
            var len = newValue.length;
            textField.setSelectionRange(len, len);
            this.setTextValue(newValue, true);
            return false;
        },

        /**
         * Handle textField blur
         * @param  {event} evt
         */
        _blur: function(evt) {
            if (evt.relatedTarget == null || !this.getDOMNode().contains(evt.relatedTarget)) {
                // HINT if this.close() fires before this._handleOptionClick() nothing happens :(
                this._timerId = setTimeout(this.close, 100);
            }
            return false;
        },

        /**
         * move option selection
         * @param  {number} direction of selction move (positive - move down, negative - move up)
         */
        _moveOptionSelection: function(direction) {
            if (this.state.isOpen) {
                var _selectedIndex = this.state._selectedIndex + direction;
                if (_selectedIndex < 0) {
                    _selectedIndex = this.state._filtratedData.length - 1;
                } else if (_selectedIndex >= this.state._filtratedData.length) {
                    _selectedIndex = 0;
                }
                this.setState({_selectedIndex: _selectedIndex}, this._scrollToSelected);
            }
        },

        /**
         * Scroll dropdown to selected element
         */
        _scrollToSelected: function() {
            var cls = clsState(clsElem('dropdownOption'), 'selected');
            this.getDOMNode().getElementsByClassName(cls)[0].scrollIntoView(false);
        },

        /**
         * Filter state._data by text
         * @param  {string=this.state._textValue} txt
         * @param  {string=this.state._data} data
         * @return {object[]}   filtrated data
         */
        _getFiltratedData: function(txt, data){
            if (txt == null) {
                txt = this.state._textValue;
            }
            if (data == null) {
                data = this.state._data;
            }

            var filtratedData = data;

            if (typeof this.props.filterFunc === 'function') {
                var filterFunc = _partial(this.props.filterFunc, txt);
                filtratedData = data.filter(filterFunc);
            }

            return filtratedData;
        },

        // Public
        /**
         * Open Combo box dropdown list is not empty
         */
        open: function() {
            var isOpen = this.state._filtratedData.length > 0;
            this.setState({
                isOpen: isOpen,
                _selectedIndex: -1
            });
        },

        /**
         * Close Combo box dropdown
         */
        close: function() {
            this.setState({
                isOpen: false
            });
        },

        /**
         * Dropdown is closed
         * @return {Boolean}
         */
        isClosed: function() {
            return !this.state.isOpen;
        },

        /**
         * Enable Combo box
         */
        enable: function() {
            this.setState({
                isEnabled: true
            });
        },

        /**
         * Disable Combo box
         */
        disable: function() {
            this.setState({
                isEnabled: false,
                isOpen: false
            });
        },

        /**
         * Combobox is disabled
         * @return {Boolean}
         */
        isDisabled: function() {
            return !this.state.isEnabled;
        },

        /**
         * Set Combobox text value
         * @param {string} newValue
         * @param {bool} open if passable
         */
        setTextValue: function(newValue, open) {
            open = open || false;
            var newData = this._getFiltratedData(newValue);

            this.setState({
                _textValue: newValue,
                _filtratedData: newData,
                isOpen: open && (newData.length > 0)
            });
        },

        /**
         * Set data items
         * @param {object[]} array of dataItems for <Option/>
         */
        setData: function(data) {
            var newFiltratedData = this._getFiltratedData(this.state._textValue, data);

            this.setState({
                _filtratedData: newFiltratedData,
                _data: data,
                _selectedIndex: -1,
                _selectedOptionData: null
            });
        },

        /**
         * Get value
         * @return {string|object} value
         */
        value: function() {
            var result = this.state._selectedOptionData || this.state._textValue;
            return result;
        }
    });

    return Combobox;
})(React);
